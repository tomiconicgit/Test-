<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Procedural Mechzilla (Three.js, single file)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
  <style>
    html, body { height:100%; margin:0; background:#0b0d10; overflow:hidden; }
    #info {
      position:fixed; left:12px; bottom:12px; color:#cfd6df; font:12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:rgba(17,20,24,.55); border:1px solid rgba(255,255,255,.08); padding:10px 12px; border-radius:10px; backdrop-filter:blur(8px)
    }
    #info b { color:#fff }
    canvas { display:block; }
  </style>
</head>
<body>
<div id="info">
  <b>Controls</b> — Orbit: mouse/touch ·
  <b>1</b>/<b>2</b> chopsticks open/close ·
  <b>Q</b>/<b>W</b> rotate QD ·
  <b>A</b>/<b>S</b> extend QD ·
  <b>Z</b>/<b>X</b> rotate upper arm
</div>

<script type="module">
/* ===== Imports (pinned, reliable) ===== */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

/* ---------- Scene / Camera / Renderer ---------- */
const scene   = new THREE.Scene();
scene.background = new THREE.Color(0x0b0d10);

const camera  = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(85, 85, 120);

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
/* Fallbacks that prevent the “black screen” trap */
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.shadowMap.enabled = true;
// renderer.physicallyCorrectLights = true; // Note: This property is deprecated in recent Three.js versions
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 70, 0);
controls.enableDamping = true;

/* ---------- Lights (robust pack) ---------- */
scene.add(new THREE.HemisphereLight(0xffffff, 0x1a1f26, 0.9)); // bright sky/ground fill
scene.add(new THREE.AmbientLight(0xffffff, 0.25));             // extra base fill

const sun = new THREE.DirectionalLight(0xffffff, 1.1);
sun.position.set(120, 200, 80);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.left = -300;
sun.shadow.camera.right = 300;
sun.shadow.camera.top = 300;
sun.shadow.camera.bottom = -300;
scene.add(sun);

/* ---------- Ground ---------- */
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(1200, 1200),
  new THREE.MeshStandardMaterial({ color:0x2a2f36, metalness:0.2, roughness:0.95 })
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

/* ---------- Debug probe (set false to remove) ---------- */
const DEBUG_PROBE = true;
if (DEBUG_PROBE) {
  scene.add(new THREE.AxesHelper(10));
  const probe = new THREE.Mesh(
    new THREE.BoxGeometry(5,5,5),
    new THREE.MeshStandardMaterial({color:0x66aaff, metalness:.6, roughness:.4})
  );
  probe.position.set(0,5,0);
  probe.castShadow = true;
  scene.add(probe);
}

/* ---------- Materials ---------- */
const steel = new THREE.MeshStandardMaterial({ color:0x8c949c, metalness:0.85, roughness:0.35 });
const darkSteel = new THREE.MeshStandardMaterial({ color:0x3a3f45, metalness:0.9, roughness:0.45 });

/* ===========================================================
   Procedural Tower (truss) + Arms
   =========================================================== */
const tower = new THREE.Group();
scene.add(tower);

const params = {
  towerHeight: 140,
  segmentH: 6,
  bay: 12,
  brace: 1.3,
  leg: 2.0,
  baseOffset: 0,
  chopstickOpen: 9,
  chopstickAngle: 0,
  qdYaw: -22,
  qdExtend: 22,
  topYaw: -8
};

/* ---------- Build tower lattice ---------- */
function buildTower() {
  tower.clear();

  const { towerHeight, segmentH, bay, brace, leg, baseOffset } = params;
  const segments = Math.floor(towerHeight / segmentH);

  const ring = new THREE.Group();
  tower.add(ring);
  ring.position.y = baseOffset;

  // Four vertical legs (InstancedMesh)
  const legGeom = new THREE.BoxGeometry(leg, segmentH, leg);
  const legMesh = new THREE.InstancedMesh(legGeom, steel, 4 * segments);
  legMesh.castShadow = true; legMesh.receiveShadow = true;
  let m = new THREE.Matrix4(); let i = 0;

  const corners = [
    new THREE.Vector3( bay/2, 0,  bay/2),
    new THREE.Vector3(-bay/2, 0,  bay/2),
    new THREE.Vector3(-bay/2, 0, -bay/2),
    new THREE.Vector3( bay/2, 0, -bay/2),
  ];

  for (let s = 0; s < segments; s++) {
    const y = s*segmentH + segmentH/2;
    for (const c of corners) {
      m.compose(new THREE.Vector3(c.x, y, c.z), new THREE.Quaternion(), new THREE.Vector3(1,1,1));
      legMesh.setMatrixAt(i++, m);
    }
  }
  ring.add(legMesh);

  // Horizontal rings (Corrected)
  const hGeom = new THREE.BoxGeometry(bay - leg, brace, leg);
  const vGeom = new THREE.BoxGeometry(leg, brace, bay - leg);

  const ringCount = segments + 1;
  // Create TWO InstancedMesh objects: one for horizontal, one for vertical
  const horizMesh = new THREE.InstancedMesh(hGeom, steel, ringCount * 4);
  const vertMesh = new THREE.InstancedMesh(vGeom, steel, ringCount * 4);
  horizMesh.castShadow = vertMesh.castShadow = true;
  horizMesh.receiveShadow = vertMesh.receiveShadow = true;
  
  let i_h = 0; // Index for horizontal meshes
  let i_v = 0; // Index for vertical meshes

  for (let r = 0; r < ringCount; r++) {
    const y = r * segmentH;

    // Define positions for the two sets of rings
    const topRingY = y + brace * 1.1;

    // --- Populate Horizontal Mesh ---
    m.identity().setPosition(0, y, bay/2);
    horizMesh.setMatrixAt(i_h++, m);
    m.identity().setPosition(0, y, -bay/2);
    horizMesh.setMatrixAt(i_h++, m);
    m.identity().setPosition(0, topRingY, bay/2);
    horizMesh.setMatrixAt(i_h++, m);
    m.identity().setPosition(0, topRingY, -bay/2);
    horizMesh.setMatrixAt(i_h++, m);

    // --- Populate Vertical Mesh ---
    m.identity().setPosition(bay/2, y, 0);
    vertMesh.setMatrixAt(i_v++, m);
    m.identity().setPosition(-bay/2, y, 0);
    vertMesh.setMatrixAt(i_v++, m);
    m.identity().setPosition(bay/2, topRingY, 0);
    vertMesh.setMatrixAt(i_v++, m);
    m.identity().setPosition(-bay/2, topRingY, 0);
    vertMesh.setMatrixAt(i_v++, m);
  }
  // Add both correct meshes to the scene graph
  ring.add(horizMesh, vertMesh);


  // Diagonal braces
  const dGeom = new THREE.BoxGeometry(brace, Math.hypot(segmentH, bay-leg), brace);
  const diag = new THREE.InstancedMesh(dGeom, darkSteel, segments * 8);
  diag.castShadow = true;
  i = 0;

  const faces = [
    { a:[-bay/2+leg/2, 0, -bay/2+leg/2], b:[ bay/2-leg/2, segmentH, -bay/2+leg/2] },
    { a:[ bay/2-leg/2, 0,  bay/2-leg/2], b:[-bay/2+leg/2, segmentH,  bay/2-leg/2] },
    { a:[-bay/2+leg/2, 0,  bay/2-leg/2], b:[-bay/2+leg/2, segmentH, -bay/2+leg/2] },
    { a:[ bay/2-leg/2, 0, -bay/2+leg/2], b:[ bay/2-leg/2, segmentH,  bay/2-leg/2] },
  ];

  for (let s = 0; s < segments; s++) {
    const y0 = s*segmentH, y1 = (s+1)*segmentH;
    const flip = (s%2===0) ? 1 : -1;
    for (const f of faces) {
      const from = new THREE.Vector3(f.a[0], y0, f.a[2]);
      const to   = new THREE.Vector3(f.b[0], y1, f.b[2]);
      if (flip < 0) [to.x, from.x] = [from.x, to.x], [to.z, from.z] = [from.z, to.z];
      const mid = from.clone().add(to).multiplyScalar(0.5);
      const dir = to.clone().sub(from);
      const len = dir.length();
      const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir.normalize());
      const scale = new THREE.Vector3(1, len/dGeom.parameters.height, 1);
      m.compose(mid, quat, scale);
      diag.setMatrixAt(i++, m);
    }
  }
  ring.add(diag);

  // Top deck
  const deck = new THREE.Mesh(
    new THREE.BoxGeometry(bay*1.2, brace*2, bay*1.2),
    darkSteel
  );
  deck.position.set(0, segments*segmentH + brace*2, 0);
  deck.castShadow = true; deck.receiveShadow = true;
  ring.add(deck);

  // Base plinth
  const base = new THREE.Mesh(
    new THREE.BoxGeometry(bay*1.6, 6, bay*1.6),
    new THREE.MeshStandardMaterial({ color:0x252a31, metalness:.2, roughness:.9 })
  );
  base.position.y = -3 + baseOffset;
  base.receiveShadow = true;
  ring.add(base);

  buildArms(segments*segmentH);
}

/* ---------- Arms ---------- */
let chopstickGrp, qdGrp, topArmGrp;

function makeTrussBeam(len = 30, depth = 4, thickness = 1.2, mat = darkSteel) {
  const g = new THREE.Group();

  const railGeom = new THREE.BoxGeometry(len, thickness, thickness);
  const rail1 = new THREE.Mesh(railGeom, mat);
  const rail2 = new THREE.Mesh(railGeom, mat);
  rail1.position.set(0,  depth/2, 0);
  rail2.position.set(0, -depth/2, 0);
  rail1.castShadow = rail2.castShadow = true;
  g.add(rail1, rail2);

  const uprGeom = new THREE.BoxGeometry(thickness, depth, thickness);
  const uprCount = Math.max(2, Math.floor(len / 4));
  for (let i=0;i<=uprCount;i++){
    const x = -len/2 + (len/uprCount)*i;
    const u = new THREE.Mesh(uprGeom, mat);
    u.position.set(x, 0, 0);
    u.castShadow = true;
    g.add(u);
  }

  const diagGeom = new THREE.BoxGeometry(thickness, Math.hypot(depth, len/uprCount), thickness);
  for (let i=0;i<uprCount;i++){
    const x0 = -len/2 + (len/uprCount)*i;
    const x1 = -len/2 + (len/uprCount)*(i+1);
    const midX = (x0+x1)/2;
    const flip = (i%2===0) ? 1 : -1;
    const segLen = x1-x0;
    const quat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0,0,Math.atan2(depth*flip, segLen)));
    const d = new THREE.Mesh(diagGeom, mat);
    d.position.set(midX, 0, 0);
    d.quaternion.copy(quat);
    d.castShadow = true;
    g.add(d);
  }
  return g;
}

function buildArms(totalH) {
  const hubY_chop = totalH * 0.33;
  const hubY_qd   = totalH * 0.58;
  const hubY_top  = totalH * 0.80;

  // Lower “chopsticks”
  chopstickGrp = new THREE.Group();
  chopstickGrp.position.set(0, hubY_chop, 0);
  tower.add(chopstickGrp);

  const chopL = new THREE.Group(), chopR = new THREE.Group();
  const chopLen = 36, fingerLen = 10;

  const beamL = makeTrussBeam(chopLen, 5, 1.2, darkSteel);
  const beamR = makeTrussBeam(chopLen, 5, 1.2, darkSteel);
  beamL.position.x = -chopLen/2; beamR.position.x = chopLen/2;

  const fingerGeom = new THREE.BoxGeometry(1.2, 6, 1.2);
  const fingerMat = steel;
  const fingerL = new THREE.Mesh(fingerGeom, fingerMat);
  fingerL.position.set(-chopLen, 0, 0);
  fingerL.castShadow = true;
  fingerL.scale.y = fingerLen/6;

  const fingerR = fingerL.clone(); fingerR.position.x *= -1;

  chopL.add(beamL, fingerL);
  chopR.add(beamR, fingerR);

  const hingeL = new THREE.Group();
  const hingeR = new THREE.Group();
  hingeL.add(chopL); hingeR.add(chopR);
  chopL.position.x =  params.chopstickOpen*-0.5;
  chopR.position.x =  params.chopstickOpen* 0.5;

  hingeL.rotation.z =  THREE.MathUtils.degToRad(params.chopstickAngle);
  hingeR.rotation.z = -THREE.MathUtils.degToRad(params.chopstickAngle);

  const mount = new THREE.Group();
  mount.position.set(params.bay/2 + 1.0, 0, 0);
  chopstickGrp.add(mount);
  mount.add(hingeL, hingeR);

  // Mid QD arm
  qdGrp = new THREE.Group();
  qdGrp.position.set(0, hubY_qd, 0);
  tower.add(qdGrp);

  const qdPivot = new THREE.Group();
  qdPivot.position.set(params.bay/2 + 1.0, 0, 0);
  qdPivot.rotation.y = THREE.MathUtils.degToRad(params.qdYaw);
  qdGrp.add(qdPivot);

  const qdOuter = makeTrussBeam(48, 6, 1.2, darkSteel);
  qdOuter.position.x = 24;

  const qdInner = makeTrussBeam(22, 5, 1.0, steel);
  qdInner.position.x = 24 + params.qdExtend;

  const head = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 2, 16), steel);
  head.rotation.z = Math.PI/2;
  head.position.set(24 + params.qdExtend + 12, 0, 0);
  head.castShadow = true;

  qdPivot.add(qdOuter, qdInner, head);

  // Upper stabilizer arm
  topArmGrp = new THREE.Group();
  topArmGrp.position.set(0, hubY_top, 0);
  tower.add(topArmGrp);

  const topPivot = new THREE.Group();
  topPivot.position.set(params.bay/2 + 1.0, 0, 0);
  topPivot.rotation.y = THREE.MathUtils.degToRad(params.topYaw);
  topArmGrp.add(topPivot);

  const topArm = makeTrussBeam(38, 5, 1.1, darkSteel);
  topArm.position.x = 19;
  const guide = new THREE.Mesh(new THREE.BoxGeometry(3, 8, 3), steel);
  guide.position.set(38, 0, 0);
  guide.castShadow = true;
  topPivot.add(topArm, guide);

  // Decorative hinge blocks
  const hingeGeom = new THREE.CylinderGeometry(2.2, 2.2, 3, 18);
  for (const y of [hubY_chop, hubY_qd, hubY_top]) {
    const h = new THREE.Mesh(hingeGeom, steel);
    h.rotation.z = Math.PI/2;
    h.position.set(params.bay/2+1.0, y, 0);
    h.castShadow = true;
    tower.add(h);
  }
}

buildTower();

/* ---------- GUI ---------- */
const gui = new GUI({ title:'Mechzilla Controls' });
const f1 = gui.addFolder('Tower');
f1.add(params, 'towerHeight', 80, 200, 1).onFinishChange(buildTower);
f1.add(params, 'segmentH', 4, 10, 1).onFinishChange(buildTower);
f1.add(params, 'bay', 8, 20, 0.5).onFinishChange(buildTower);
f1.add(params, 'baseOffset', -10, 20, 1).onFinishChange(buildTower);

const f2 = gui.addFolder('Chopsticks');
f2.add(params, 'chopstickOpen', 2, 30, 0.5).name('gap').onChange(v=>{
  chopstickGrp.children[0].children[0].position.x = -v*0.5; // L
  chopstickGrp.children[0].children[1].position.x =  v*0.5; // R
});
f2.add(params, 'chopstickAngle', -15, 15, 0.5).onChange(v=>{
  const L = chopstickGrp.children[0].children[0].parent;
  const R = chopstickGrp.children[0].children[1].parent;
  L.rotation.z =  THREE.MathUtils.degToRad(v);
  R.rotation.z = -THREE.MathUtils.degToRad(v);
});

const f3 = gui.addFolder('QD Arm');
f3.add(params, 'qdYaw', -60, 10, 1).onChange(v=>{
  qdGrp.children[0].rotation.y = THREE.MathUtils.degToRad(v);
});
f3.add(params, 'qdExtend', 0, 36, 0.5).onChange(v=>{
  const pivot = qdGrp.children[0];
  pivot.children[1].position.x = 24 + v;        // inner beam
  pivot.children[2].position.x = 24 + v + 12;   // head
});

const f4 = gui.addFolder('Top Arm');
f4.add(params, 'topYaw', -45, 15, 1).onChange(v=>{
  topArmGrp.children[0].rotation.y = THREE.MathUtils.degToRad(v);
});
gui.close();

/* ---------- Keyboard shortcuts ---------- */
window.addEventListener('keydown', (e)=>{
  switch(e.key.toLowerCase()){
    case '1': params.chopstickOpen = Math.min(30, params.chopstickOpen + 1); break;
    case '2': params.chopstickOpen = Math.max(2,  params.chopstickOpen - 1); break;
    case 'q': params.qdYaw -= 1;  break;
    case 'w': params.qdYaw += 1;  break;
    case 'a': params.qdExtend = Math.max(0, params.qdExtend - 1); break;
    case 's': params.qdExtend = Math.min(36, params.qdExtend + 1); break;
    case 'z': params.topYaw -= 1; break;
    case 'x': params.topYaw += 1; break;
  }
  // reflect updates
  f2.controllers[0].setValue(params.chopstickOpen);
  f3.controllers[0].setValue(params.qdYaw);
  f3.controllers[1].setValue(params.qdExtend);
  f4.controllers[0].setValue(params.topYaw);
});

/* ---------- Animate ---------- */
function animate(){
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
